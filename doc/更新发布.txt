【更新发布方案】

0. 停止全部服务器，全部更新，全部重启。
【这里可能还包括需要更新客户端】
更新频率不会太高，重启够快，这个方案最简单，虽然之后会出现一定的登录高峰，但一般都扛的住。
但系统规模越来越大，更新频率可能也会越来越高，这会导致大量重启，此时就需要考虑其他方式了。
【这个方案总是可用。在下面的方案无法使用的时候，总是可以选择它】

1. 一台一台更新服务器。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。
方案实现草稿：
a) App 需要定义版本号。
b) 调用 Schemas.setAppPublishVersion
c) server 给linkd报告Info时带上版本号。
d) linkd 发现多个版本号，则只给最新的分发新登录。
e) 新旧版有同时运行的时刻，后端数据库访问的时候，旧版不能把新版新增的变量搞丢了。【已实现，下面碰到这个需求不再列出】
【分析】这是个接近完全重启，但又带来需要新旧版同时运行并兼容的问题的方案。
【分析】实际使用价值不大，主要是提出了这个问题。后面方案3会重新涉及这个问题。

2. 新旧版本同时运行，分成两个集合，两者之间几乎没有交互。旧集合逐步关闭。
a) ServiceManager 在动态管理服务器时，不能把两个集合混起来。
【通过应用提供的带上版本号的PrefixName自动形成不同的集合】【Zeze已支持，由应用进行配置】
b) 新旧集合之间可能需要通讯，Zeze需要提供一点支持。【TODO】
c) 这个方案难点在于应用的所有功能能不能得到合理安排。【XXX】
e) Linkd使用独立发现（DNS）,新旧版连接到不同的Linkd集合。
【每个版本都需要更新DNS？】
【DNS不属于Zeze功能，但Linkd发现，Zeze以后是否需要提供支持机制？（DNS已经够好了，自己提供价值不大）】
f) 在更新频率高的时候，如果只是新旧两个，也是扛不住的。可能需要扩展成同时运行更多版本。
【分析】这是个奇特的方案，它最主要的目的是降低兼容性的压力，但个人感觉这个方案不可预测。

3. 基于ClassLoader局部模块热更。
服务器不需要重启，按Module为单位热更。一次更新可以包含多个模块。不考虑多个Module打包成Bundle模式，避免引入新的概念。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。这个问题同方案1，但有点区别。
因为是局部更新，服务器没有重启，所以有个解决思路：所有服务器为单位原子的热更。只要这个原子化锁定时间够短，是可行的。【TODO】
【问题】几个模块一起热更，存在更新顺序问题。【已解决，见后HotReadWriteLock】
【问题】模块功能兼容性必须成为开发者的一个基本需求。绕开这个问题的方案都过于理想了。当兼容代价太大，使用方案0(停止世界再重启)即可.

方案实现草稿：【下面几乎都是TODO，不单独标出来了】
a) 可选的定义App版本号，任何Module需要更新，都会同时更新App版本号。这样方案1的Linkd只给新版分发新登录会自动生效。
b) 每个Module一个ClassLoader，这是实现热更的技术基础。
c) 热更最根本的操作是生成Module的新实例，并发布，即更新相关地方的引用。如：App里的全局引用，Zeze里面Table的引用，重新注册协议。
d) HotReadWriteLock 所有的线程执行的时候加读锁，热更的时候加写锁。进程内热更需要加锁的主要是发布引用，很快，其他步骤不需要的尽量锁外执行。
这个锁内多个Module一起热更，所以顺便解决了上面热更顺序问题。
e) App的Module构造|初始化|Start顺序定义继续保留，是否需要修订？列出这个，备注一下。
f) 所有服务器为单位进行原子的热更。上面第一个问题，避免新旧版本同时运行就可以实现了，能不能用就看实际疗效了。
g) AppVersion更新；自动打包工具；自动检测需要更新的模块，可行？
h) 原则：模块引用不能保存；模块直接保留Table的引用不能保存；模块暴露的所有引用？数据对象(如Bean)允许保存下来？

我准备先按纯interface的方式，设想一下整个热更发布系统。
规则0：纯interface+不能把从别的module.classloader装载得到的对象引用保存下来。
规则1：module暴露自己内部的table出去不能使用最终类型，必须是Zeze.Transaction.Table。这个还需要实验一下。
规则2：module，bean，interface化，需要涉及interface多版本的解决方案。
规则3：module interface是唯一的注册到框架的服务接口。
规则4：module interface 的函数参数类型只能是本名字空间下的interface和其他。都必须是能由框架loader装载的。
这里本空间的interface需要特殊判断。参数是lamda是可以的，它也是interface的一种。
规则5：静态变量和静态方法也需要用interface包装。
规则6：zeze不准备支持热更，暴露的服务如果有订阅注册，全部需要规划。先举个例子：timer使用className和callback跟外面交互，
其中className方式具有自动动态特性，刚好符合要求，但是callback需要处理（改造成className？）。等等。
这是基本版，当出现需要保存得到的interface引用时，看看能不能制定出合适的规则。
timer class.forName还是需要实验一下。这里是不是也涉及到了import class。
影响开发的规则：
0. 接口参数限制，基本类型，bean会自动得到支持，自定义类型必须interface化。
1. 不能保存别的模块得到的引用。确实需要再看怎么解决。
2. 建议无状态。确实需要，最好状态仅限内部使用，是不公开的。upgradeFrom(ModuleSome oldInstance) ，状态倒入。 
4. “所有”线程任务都必须通过Task管理，用来和热更互斥，当然也有允许例外，即确定不需要保护时也可以自己管理线程。
5. 新版本的接口兼容旧版本。
*. 开发限制应该就这几条了。其他尽量框架自动解决。
【规则重新总结】
module是唯一的第一公开服务，有其他公开接口，也通过module得到；
module默认所有的public方法，除了注解声明不公开外，都是接口的一部分；
发布的时候，接口自动生成，检测变化，生成不同版本；

热更发布开发计划(碰到问题，很有可能需要回头修改规则)
0. Bean 接口化。Bean接口必须兼容旧版的，多版本管理问题？
1. 模块 Table 暴露出去使用Zeze.Transaction.Table<Key, ValueBean>，由于Zeze稳定，这里预计不会碰到问题，需要实验。
2. Module接口规范，其中最基本要求是新版接口兼容旧版。多版本管理问题？
3. Module接口自动生成，需要工具进行自动解析并生成接口，并且检查是否符合规范，是否兼容性（需要保存就发布的接口，多版本管理问题）。
4. Zeze各种服务需要动态化或者能重新注册。
*) 协议重新注册。
*) Zeze内管理的Table实例覆盖（重新注册的一种，由于table有初始化需求，原来是启动静态处理的，需要能动态支持）。
Zeze已经提供了一个受限动态表，可能需要参考这个，重新设计这块的功能。
*) timerAccount timerRole 原来为了优化直接保存Handle，需要改成className，用class.forName动态化。还有没有其他方案？
*) Online模块：事件订阅和LocalData的升级。
*) Zeze的某些全局定制服务加限制，只能由应用全局设置（不会热更），不能在module里面设置。caller.classLoader!=Zeze.classLoader，能判断这个？
*) more more。

TODO
install new modiule need register sm,还需要module config  choice type
table 替换，可能有点麻烦；protocol 替换，已有包装，由hot调一下unreg
zezex 热更测试
module 生成 interface 工具（预计下周）

0. 原则
模块interface 化，所有被其他模块访问的功能和数据对象都是interface；
inteface新版兼容旧版。

第一阶段：模块是无状态的。
start 初始化启动时，solution里面可以描述启动顺序，解决依赖问题。
热更一个模块时，其他模块都是准备好的，它的依赖没问题；
依赖它的模块根据无状态和服务接口兼容特性，在运行中会得到新模块的新的interface，使用起来也没问题。
热更多个模块时，这个更新集合跟其他部分没问题，集合内部也存在start依赖，这个可以在提交热更集合时定义好顺序。
现在HotManager.install参数是List，可以描述顺序。
?  只定义这两个要求是否足够 1. 第一次启动顺序，2. 热更集合启动顺序

第二阶段：模块是有状态的。
a) 模块内部自己的私有数据，void upgrade(HotService old); 这里访问old的私有数据目前考虑也只能通过接口得到。
也就是说有状态模块需要一个 IMyAnyState getState(); 方法，其中 IMyAnyState 可能需要包含版本信息。
b) 模块缓存了其他模块创建的数据，void refresh(HotService current); 这里需要访问current的服务接口刷新本地数据。
这个只是抽象，可能还需要解决一些问题。预感没这么简单。
c) start依赖意味着此时可能缓存了其他创建的数据，那么也通过refresh刷新。
*) 有状态的a,b两种应该都不需要递归，通知一级就行，依赖关系最好能自动，实在不行就配置。这点需要继续考虑。

热更（增加）模块与模块启动依赖之间的定义有冲突。即一个模块热更对依赖它的模块的影响问题。
这样定义：start仅仅作用于启动，以后热更不需要考虑这个问题，热更仅提供服务接口的兼容。
是否可行？
当然，启动顺序还是有一定保证。
1. 服务第一次启动时，定义好的启动顺序还是保证。
2. 几个模块一起热更，它们之间启动顺序也可以保证。
3. 热更模块跟现有模块之间就不考虑启动顺序问题。
----
redirect 问题：
1. 预先生成出子类现在是全局包里面的，只用于zeze内部，不需要考虑cl；
2. app需要限制只能即时编译了，因为InMemoryJavaCompiler支持设置parent classloader，
所以，启用了热更，设置一下，可能就没有问题了。这个需要确认。 

技术笔记：
OSGi ClassLoader 将按照下面的顺序进行类搜索：
1）将以java.*开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类查找失败。
【选择】OSGi 特性是很多的，大砍特砍，仅保留热更发布。
【选择】模块多版本同时存在需求考虑一下。目前判断是不可行。

4. Arch.Linkd.ChoiceProvider 机制上花招。


【异想天开】
0. 兼容是开发人员绕不开的问题，只能降低难度，但永远避免不了。特别是服务器开发人员。
1. 客户端也支持按模块热更就完美了。
2. 后端数据库需求，高效的设置不安全点，此后较长一段时间（如，一天）的数据修改可以全部快速回滚，
当然也可以设为安全，把修改提交，然后一切正常继续。用于版本更新时，减少重大bug引起的大问题。
对于游戏，回滚期间产生的高价值掉落，通过log给玩家补上。
